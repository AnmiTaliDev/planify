/* Application.c generated by valac 0.50.10, the Vala compiler
 * generated from Application.vala, do not modify */

/*
* Copyright (c) 2017 Daniel For√© (http://danielfore.com)
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License as published by the Free Software Foundation; either
* version 2 of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
* Boston, MA 02110-1301 USA
*
*/

#include <gtk/gtk.h>
#include <glib-object.h>
#include <handy.h>
#include <gio/gio.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <stdio.h>
#include <gdk/gdk.h>
#include <glib/gstdio.h>
#include <locale.h>

#define TYPE_PLANNER (planner_get_type ())
#define PLANNER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PLANNER, Planner))
#define PLANNER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PLANNER, PlannerClass))
#define IS_PLANNER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PLANNER))
#define IS_PLANNER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PLANNER))
#define PLANNER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PLANNER, PlannerClass))

typedef struct _Planner Planner;
typedef struct _PlannerClass PlannerClass;
typedef struct _PlannerPrivate PlannerPrivate;

#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;
enum  {
	PLANNER_0_PROPERTY,
	PLANNER_NUM_PROPERTIES
};
static GParamSpec* planner_properties[PLANNER_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define SERVICES_TYPE_DATABASE (services_database_get_type ())
#define SERVICES_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_DATABASE, ServicesDatabase))
#define SERVICES_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_DATABASE, ServicesDatabaseClass))
#define SERVICES_IS_DATABASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_DATABASE))
#define SERVICES_IS_DATABASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_DATABASE))
#define SERVICES_DATABASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_DATABASE, ServicesDatabaseClass))

typedef struct _ServicesDatabase ServicesDatabase;
typedef struct _ServicesDatabaseClass ServicesDatabaseClass;

#define SERVICES_TYPE_EVENT_BUS (services_event_bus_get_type ())
#define SERVICES_EVENT_BUS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_EVENT_BUS, ServicesEventBus))
#define SERVICES_EVENT_BUS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_EVENT_BUS, ServicesEventBusClass))
#define SERVICES_IS_EVENT_BUS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_EVENT_BUS))
#define SERVICES_IS_EVENT_BUS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_EVENT_BUS))
#define SERVICES_EVENT_BUS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_EVENT_BUS, ServicesEventBusClass))

typedef struct _ServicesEventBus ServicesEventBus;
typedef struct _ServicesEventBusClass ServicesEventBusClass;

#define SERVICES_TYPE_TODOIST (services_todoist_get_type ())
#define SERVICES_TODOIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SERVICES_TYPE_TODOIST, ServicesTodoist))
#define SERVICES_TODOIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SERVICES_TYPE_TODOIST, ServicesTodoistClass))
#define SERVICES_IS_TODOIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SERVICES_TYPE_TODOIST))
#define SERVICES_IS_TODOIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SERVICES_TYPE_TODOIST))
#define SERVICES_TODOIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SERVICES_TYPE_TODOIST, ServicesTodoistClass))

typedef struct _ServicesTodoist ServicesTodoist;
typedef struct _ServicesTodoistClass ServicesTodoistClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_settings_schema_unref0(var) ((var == NULL) ? NULL : (var = (g_settings_schema_unref (var), NULL)))
#define _g_settings_schema_source_unref0(var) ((var == NULL) ? NULL : (var = (g_settings_schema_source_unref (var), NULL)))

#define TYPE_UTIL (util_get_type ())
#define UTIL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UTIL, Util))
#define UTIL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UTIL, UtilClass))
#define IS_UTIL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UTIL))
#define IS_UTIL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UTIL))
#define UTIL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UTIL, UtilClass))

typedef struct _Util Util;
typedef struct _UtilClass UtilClass;

struct _Planner {
	GtkApplication parent_instance;
	PlannerPrivate * priv;
	MainWindow* main_window;
};

struct _PlannerClass {
	GtkApplicationClass parent_class;
};

static gpointer planner_parent_class = NULL;
static gboolean planner_version;
static gboolean planner_clear_database;
static gboolean planner_silent;
static gchar* planner_lang;
extern GSettings* planner_settings;
GSettings* planner_settings = NULL;
extern ServicesDatabase* planner_database;
ServicesDatabase* planner_database = NULL;
extern ServicesEventBus* planner_event_bus;
ServicesEventBus* planner_event_bus = NULL;
extern ServicesTodoist* planner_todoist;
ServicesTodoist* planner_todoist = NULL;
extern Planner* planner__instance;
Planner* planner__instance = NULL;
static gboolean planner_silent = FALSE;
static gboolean planner_version = FALSE;
static gboolean planner_clear_database = FALSE;
static gchar* planner_lang = NULL;

GType planner_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Planner, g_object_unref)
GType main_window_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (MainWindow, g_object_unref)
GType services_database_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ServicesDatabase, g_object_unref)
GType services_event_bus_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ServicesEventBus, g_object_unref)
GType services_todoist_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (ServicesTodoist, g_object_unref)
static void planner_real_activate (GApplication* base);
#define CONSTANTS_VERSION "3.0-beta1"
MainWindow* main_window_new (GtkApplication* application);
MainWindow* main_window_construct (GType object_type,
                                   GtkApplication* application);
GType util_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Util, g_object_unref)
Util* util_get_default (void);
void util_update_theme (Util* self);
void planner_create_dir_with_parents (Planner* self,
                                      const gchar* dir);
static gint planner_main (gchar** args,
                   gint args_length1);
Planner* planner_get_instance (void);
Planner* planner_new (void);
Planner* planner_construct (GType object_type);
static GObject * planner_constructor (GType type,
                               guint n_construct_properties,
                               GObjectConstructParam * construct_properties);
#define CONSTANTS_INSTALL_PREFIX "/app"
#define CONSTANTS_GETTEXT_PACKAGE "com.github.alainm23.planner"
ServicesEventBus* services_event_bus_new (void);
ServicesEventBus* services_event_bus_construct (GType object_type);
static void planner_finalize (GObject * obj);
static GType planner_get_type_once (void);
static void _vala_planner_get_property (GObject * object,
                                 guint property_id,
                                 GValue * value,
                                 GParamSpec * pspec);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

const GOptionEntry PLANNER_PLANNER_OPTIONS[5] = {{"version", 'v', 0, G_OPTION_ARG_NONE, &planner_version, "Display version number", NULL}, {"reset", 'r', 0, G_OPTION_ARG_NONE, &planner_clear_database, "Reset Planner", NULL}, {"silent", 's', 0, G_OPTION_ARG_NONE, &planner_silent, "Run the Application in background", NULL}, {"lang", 'l', 0, G_OPTION_ARG_STRING, &planner_lang, "Open Planner in a specific language", "LANG"}, {NULL}};

static gchar*
g_file_stream_read_line (FILE* self)
{
	gint c = 0;
	GString* ret = NULL;
	GString* _tmp3_;
	gchar* result = NULL;
#line 3840 "glib-2.0.vapi"
	g_return_val_if_fail (self != NULL, NULL);
#line 3842 "glib-2.0.vapi"
	ret = NULL;
#line 3843 "glib-2.0.vapi"
	while (TRUE) {
#line 202 "Application.c"
		GString* _tmp0_;
		GString* _tmp2_;
#line 3843 "glib-2.0.vapi"
		c = fgetc (self);
#line 3843 "glib-2.0.vapi"
		if (!(c != EOF)) {
#line 3843 "glib-2.0.vapi"
			break;
#line 211 "Application.c"
		}
#line 3844 "glib-2.0.vapi"
		_tmp0_ = ret;
#line 3844 "glib-2.0.vapi"
		if (_tmp0_ == NULL) {
#line 217 "Application.c"
			GString* _tmp1_;
#line 3845 "glib-2.0.vapi"
			_tmp1_ = g_string_new ("");
#line 3845 "glib-2.0.vapi"
			_g_string_free0 (ret);
#line 3845 "glib-2.0.vapi"
			ret = _tmp1_;
#line 225 "Application.c"
		}
#line 3847 "glib-2.0.vapi"
		if (c == ((gint) '\n')) {
#line 3848 "glib-2.0.vapi"
			break;
#line 231 "Application.c"
		}
#line 3850 "glib-2.0.vapi"
		_tmp2_ = ret;
#line 3850 "glib-2.0.vapi"
		g_string_append_c ((GString*) _tmp2_, (gchar) c);
#line 237 "Application.c"
	}
#line 3852 "glib-2.0.vapi"
	_tmp3_ = ret;
#line 3852 "glib-2.0.vapi"
	if (_tmp3_ == NULL) {
#line 3853 "glib-2.0.vapi"
		result = NULL;
#line 3853 "glib-2.0.vapi"
		_g_string_free0 (ret);
#line 3853 "glib-2.0.vapi"
		return result;
#line 249 "Application.c"
	} else {
		GString* _tmp4_;
		const gchar* _tmp5_;
		gchar* _tmp6_;
#line 3855 "glib-2.0.vapi"
		_tmp4_ = ret;
#line 3855 "glib-2.0.vapi"
		_tmp5_ = ((GString*) _tmp4_)->str;
#line 3855 "glib-2.0.vapi"
		_tmp6_ = g_strdup (_tmp5_);
#line 3855 "glib-2.0.vapi"
		result = _tmp6_;
#line 3855 "glib-2.0.vapi"
		_g_string_free0 (ret);
#line 3855 "glib-2.0.vapi"
		return result;
#line 266 "Application.c"
	}
#line 3840 "glib-2.0.vapi"
	_g_string_free0 (ret);
#line 270 "Application.c"
}

static gpointer
_g_settings_schema_source_ref0 (gpointer self)
{
#line 113 "../src/Application.vala"
	return self ? g_settings_schema_source_ref (self) : NULL;
#line 278 "Application.c"
}

static void
planner_real_activate (GApplication* base)
{
	Planner * self;
	const gchar* _tmp0_;
	MainWindow* _tmp2_;
	MainWindow* _tmp36_;
	gint window_x = 0;
	gint window_y = 0;
	gint width = 0;
	gint height = 0;
	GSettings* _tmp37_;
	gint _tmp38_ = 0;
	gint _tmp39_ = 0;
	GSettings* _tmp40_;
	gint _tmp41_ = 0;
	gint _tmp42_ = 0;
	gboolean _tmp43_ = FALSE;
	gboolean _tmp45_ = FALSE;
	GSettings* _tmp48_;
	GtkCssProvider* provider = NULL;
	GtkCssProvider* _tmp51_;
	GtkCssProvider* _tmp52_;
	GdkScreen* _tmp53_;
	GtkCssProvider* _tmp54_;
	Util* _tmp55_;
	Util* _tmp56_;
	GError* _inner_error0_ = NULL;
#line 74 "../src/Application.vala"
	self = (Planner*) base;
#line 75 "../src/Application.vala"
	_tmp0_ = planner_lang;
#line 75 "../src/Application.vala"
	if (g_strcmp0 (_tmp0_, "") != 0) {
#line 315 "Application.c"
		const gchar* _tmp1_;
#line 76 "../src/Application.vala"
		_tmp1_ = planner_lang;
#line 76 "../src/Application.vala"
		g_setenv ("LANGUAGE", _tmp1_, TRUE);
#line 321 "Application.c"
	}
#line 79 "../src/Application.vala"
	_tmp2_ = self->main_window;
#line 79 "../src/Application.vala"
	if (_tmp2_ != NULL) {
#line 327 "Application.c"
		gint x = 0;
		gint y = 0;
		GSettings* _tmp3_;
		gint _tmp4_ = 0;
		gint _tmp5_ = 0;
		gboolean _tmp6_ = FALSE;
		MainWindow* _tmp8_;
#line 81 "../src/Application.vala"
		_tmp3_ = planner_settings;
#line 81 "../src/Application.vala"
		g_settings_get (_tmp3_, "window-position", "(ii)", &_tmp4_, &_tmp5_);
#line 81 "../src/Application.vala"
		x = _tmp4_;
#line 81 "../src/Application.vala"
		y = _tmp5_;
#line 82 "../src/Application.vala"
		if (x != -1) {
#line 82 "../src/Application.vala"
			_tmp6_ = TRUE;
#line 347 "Application.c"
		} else {
#line 82 "../src/Application.vala"
			_tmp6_ = y != -1;
#line 351 "Application.c"
		}
#line 82 "../src/Application.vala"
		if (_tmp6_) {
#line 355 "Application.c"
			MainWindow* _tmp7_;
#line 83 "../src/Application.vala"
			_tmp7_ = self->main_window;
#line 83 "../src/Application.vala"
			gtk_window_move ((GtkWindow*) _tmp7_, x, y);
#line 361 "Application.c"
		}
#line 86 "../src/Application.vala"
		_tmp8_ = self->main_window;
#line 86 "../src/Application.vala"
		gtk_window_present ((GtkWindow*) _tmp8_);
#line 88 "../src/Application.vala"
		return;
#line 369 "Application.c"
	}
#line 91 "../src/Application.vala"
	if (planner_version) {
#line 373 "Application.c"
		gchar* _tmp9_;
		gchar* _tmp10_;
#line 92 "../src/Application.vala"
		_tmp9_ = g_strdup_printf ("%s\n", CONSTANTS_VERSION);
#line 92 "../src/Application.vala"
		_tmp10_ = _tmp9_;
#line 92 "../src/Application.vala"
		g_print ("%s", _tmp10_);
#line 92 "../src/Application.vala"
		_g_free0 (_tmp10_);
#line 93 "../src/Application.vala"
		return;
#line 386 "Application.c"
	}
#line 96 "../src/Application.vala"
	if (planner_clear_database) {
#line 390 "Application.c"
		gchar* _tmp11_;
		gchar* _tmp12_;
		gchar* input = NULL;
		FILE* _tmp13_;
		gchar* _tmp14_;
		gboolean _tmp15_ = FALSE;
		const gchar* _tmp16_;
#line 97 "../src/Application.vala"
		_tmp11_ = g_strdup_printf ("%s\n", _ ("Are you sure you want to reset all?"));
#line 97 "../src/Application.vala"
		_tmp12_ = _tmp11_;
#line 97 "../src/Application.vala"
		g_print ("%s", _tmp12_);
#line 97 "../src/Application.vala"
		_g_free0 (_tmp12_);
#line 98 "../src/Application.vala"
		g_print ("%s", _ ("It process removes all stored information without the possibility of u" \
"ndoing it. (y/n): "));
#line 99 "../src/Application.vala"
		_tmp13_ = stdin;
#line 99 "../src/Application.vala"
		_tmp14_ = g_file_stream_read_line (_tmp13_);
#line 99 "../src/Application.vala"
		input = _tmp14_;
#line 101 "../src/Application.vala"
		_tmp16_ = input;
#line 101 "../src/Application.vala"
		if (g_strcmp0 (_tmp16_, _ ("y")) == 0) {
#line 101 "../src/Application.vala"
			_tmp15_ = TRUE;
#line 420 "Application.c"
		} else {
			const gchar* _tmp17_;
#line 101 "../src/Application.vala"
			_tmp17_ = input;
#line 101 "../src/Application.vala"
			_tmp15_ = g_strcmp0 (_tmp17_, _ ("yes")) == 0;
#line 427 "Application.c"
		}
#line 101 "../src/Application.vala"
		if (_tmp15_) {
#line 431 "Application.c"
			gchar* db_path = NULL;
			const gchar* _tmp18_;
			gchar* _tmp19_;
			GFile* db_file = NULL;
			const gchar* _tmp20_;
			GFile* _tmp21_;
			GFile* _tmp22_;
			GSettingsSchemaSource* schema_source = NULL;
			GSettingsSchemaSource* _tmp26_;
			GSettingsSchemaSource* _tmp27_;
			GSettingsSchema* schema = NULL;
			GSettingsSchemaSource* _tmp28_;
			GSettingsSchema* _tmp29_;
			GSettingsSchema* _tmp30_;
			gchar** _tmp31_;
			gchar** _tmp32_;
#line 102 "../src/Application.vala"
			_tmp18_ = g_get_user_data_dir ();
#line 102 "../src/Application.vala"
			_tmp19_ = g_strconcat (_tmp18_, "/com.github.alainm23.planner/database.db", NULL);
#line 102 "../src/Application.vala"
			db_path = _tmp19_;
#line 103 "../src/Application.vala"
			_tmp20_ = db_path;
#line 103 "../src/Application.vala"
			_tmp21_ = g_file_new_for_path (_tmp20_);
#line 103 "../src/Application.vala"
			db_file = _tmp21_;
#line 105 "../src/Application.vala"
			_tmp22_ = db_file;
#line 105 "../src/Application.vala"
			if (g_file_query_exists (_tmp22_, NULL)) {
#line 464 "Application.c"
				{
					GFile* _tmp23_;
#line 107 "../src/Application.vala"
					_tmp23_ = db_file;
#line 107 "../src/Application.vala"
					g_file_delete (_tmp23_, NULL, &_inner_error0_);
#line 107 "../src/Application.vala"
					if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 473 "Application.c"
						goto __catch0_g_error;
					}
				}
				goto __finally0;
				__catch0_g_error:
				{
					GError* err = NULL;
					GError* _tmp24_;
					const gchar* _tmp25_;
#line 106 "../src/Application.vala"
					err = _inner_error0_;
#line 106 "../src/Application.vala"
					_inner_error0_ = NULL;
#line 109 "../src/Application.vala"
					_tmp24_ = err;
#line 109 "../src/Application.vala"
					_tmp25_ = _tmp24_->message;
#line 109 "../src/Application.vala"
					g_warning ("Application.vala:109: %s", _tmp25_);
#line 106 "../src/Application.vala"
					_g_error_free0 (err);
#line 495 "Application.c"
				}
				__finally0:
#line 106 "../src/Application.vala"
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 106 "../src/Application.vala"
					_g_object_unref0 (db_file);
#line 106 "../src/Application.vala"
					_g_free0 (db_path);
#line 106 "../src/Application.vala"
					_g_free0 (input);
#line 106 "../src/Application.vala"
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 106 "../src/Application.vala"
					g_clear_error (&_inner_error0_);
#line 106 "../src/Application.vala"
					return;
#line 512 "Application.c"
				}
			}
#line 113 "../src/Application.vala"
			_tmp26_ = g_settings_schema_source_get_default ();
#line 113 "../src/Application.vala"
			_tmp27_ = _g_settings_schema_source_ref0 (_tmp26_);
#line 113 "../src/Application.vala"
			schema_source = _tmp27_;
#line 114 "../src/Application.vala"
			_tmp28_ = schema_source;
#line 114 "../src/Application.vala"
			_tmp29_ = g_settings_schema_source_lookup (_tmp28_, "com.github.alainm23.planner", TRUE);
#line 114 "../src/Application.vala"
			schema = _tmp29_;
#line 116 "../src/Application.vala"
			_tmp30_ = schema;
#line 116 "../src/Application.vala"
			_tmp32_ = _tmp31_ = g_settings_schema_list_keys (_tmp30_);
#line 531 "Application.c"
			{
				gchar** key_collection = NULL;
				gint key_collection_length1 = 0;
				gint _key_collection_size_ = 0;
				gint key_it = 0;
#line 116 "../src/Application.vala"
				key_collection = _tmp32_;
#line 116 "../src/Application.vala"
				key_collection_length1 = _vala_array_length (_tmp31_);
#line 116 "../src/Application.vala"
				for (key_it = 0; key_it < key_collection_length1; key_it = key_it + 1) {
#line 543 "Application.c"
					gchar* _tmp33_;
					gchar* key = NULL;
#line 116 "../src/Application.vala"
					_tmp33_ = g_strdup (key_collection[key_it]);
#line 116 "../src/Application.vala"
					key = _tmp33_;
#line 550 "Application.c"
					{
						GSettings* _tmp34_;
						const gchar* _tmp35_;
#line 117 "../src/Application.vala"
						_tmp34_ = planner_settings;
#line 117 "../src/Application.vala"
						_tmp35_ = key;
#line 117 "../src/Application.vala"
						g_settings_reset (_tmp34_, _tmp35_);
#line 116 "../src/Application.vala"
						_g_free0 (key);
#line 562 "Application.c"
					}
				}
#line 116 "../src/Application.vala"
				key_collection = (_vala_array_free (key_collection, key_collection_length1, (GDestroyNotify) g_free), NULL);
#line 567 "Application.c"
			}
#line 101 "../src/Application.vala"
			_g_settings_schema_unref0 (schema);
#line 101 "../src/Application.vala"
			_g_settings_schema_source_unref0 (schema_source);
#line 101 "../src/Application.vala"
			_g_object_unref0 (db_file);
#line 101 "../src/Application.vala"
			_g_free0 (db_path);
#line 577 "Application.c"
		}
#line 121 "../src/Application.vala"
		_g_free0 (input);
#line 121 "../src/Application.vala"
		return;
#line 583 "Application.c"
	}
#line 124 "../src/Application.vala"
	_tmp36_ = main_window_new ((GtkApplication*) self);
#line 124 "../src/Application.vala"
	g_object_ref_sink (_tmp36_);
#line 124 "../src/Application.vala"
	_g_object_unref0 (self->main_window);
#line 124 "../src/Application.vala"
	self->main_window = _tmp36_;
#line 129 "../src/Application.vala"
	_tmp37_ = planner_settings;
#line 129 "../src/Application.vala"
	g_settings_get (_tmp37_, "window-position", "(ii)", &_tmp38_, &_tmp39_);
#line 129 "../src/Application.vala"
	window_x = _tmp38_;
#line 129 "../src/Application.vala"
	window_y = _tmp39_;
#line 130 "../src/Application.vala"
	_tmp40_ = planner_settings;
#line 130 "../src/Application.vala"
	g_settings_get (_tmp40_, "window-size", "(ii)", &_tmp41_, &_tmp42_);
#line 130 "../src/Application.vala"
	width = _tmp41_;
#line 130 "../src/Application.vala"
	height = _tmp42_;
#line 132 "../src/Application.vala"
	if (window_x != -1) {
#line 132 "../src/Application.vala"
		_tmp43_ = TRUE;
#line 613 "Application.c"
	} else {
#line 132 "../src/Application.vala"
		_tmp43_ = window_y != -1;
#line 617 "Application.c"
	}
#line 132 "../src/Application.vala"
	if (_tmp43_) {
#line 621 "Application.c"
		MainWindow* _tmp44_;
#line 133 "../src/Application.vala"
		_tmp44_ = self->main_window;
#line 133 "../src/Application.vala"
		gtk_window_move ((GtkWindow*) _tmp44_, window_x, window_y);
#line 627 "Application.c"
	}
#line 136 "../src/Application.vala"
	if (width != -1) {
#line 136 "../src/Application.vala"
		_tmp45_ = TRUE;
#line 633 "Application.c"
	} else {
#line 136 "../src/Application.vala"
		_tmp45_ = height != -1;
#line 637 "Application.c"
	}
#line 136 "../src/Application.vala"
	if (_tmp45_) {
#line 641 "Application.c"
		GtkAllocation rect = {0};
		MainWindow* _tmp46_;
		GtkAllocation _tmp47_;
#line 137 "../src/Application.vala"
		memset (&rect, 0, sizeof (GtkAllocation));
#line 138 "../src/Application.vala"
		rect.height = height;
#line 139 "../src/Application.vala"
		rect.width = width;
#line 140 "../src/Application.vala"
		_tmp46_ = self->main_window;
#line 140 "../src/Application.vala"
		_tmp47_ = rect;
#line 140 "../src/Application.vala"
		gtk_widget_set_allocation ((GtkWidget*) _tmp46_, &_tmp47_);
#line 657 "Application.c"
	}
#line 143 "../src/Application.vala"
	_tmp48_ = planner_settings;
#line 143 "../src/Application.vala"
	if (g_settings_get_boolean (_tmp48_, "window-maximized")) {
#line 663 "Application.c"
		MainWindow* _tmp49_;
#line 144 "../src/Application.vala"
		_tmp49_ = self->main_window;
#line 144 "../src/Application.vala"
		gtk_window_maximize ((GtkWindow*) _tmp49_);
#line 669 "Application.c"
	}
#line 147 "../src/Application.vala"
	if (!planner_silent) {
#line 673 "Application.c"
		MainWindow* _tmp50_;
#line 148 "../src/Application.vala"
		_tmp50_ = self->main_window;
#line 148 "../src/Application.vala"
		gtk_widget_show_all ((GtkWidget*) _tmp50_);
#line 679 "Application.c"
	}
#line 151 "../src/Application.vala"
	_tmp51_ = gtk_css_provider_new ();
#line 151 "../src/Application.vala"
	provider = _tmp51_;
#line 152 "../src/Application.vala"
	_tmp52_ = provider;
#line 152 "../src/Application.vala"
	gtk_css_provider_load_from_resource (_tmp52_, "/com/github/alainm23/planner/index.css");
#line 153 "../src/Application.vala"
	_tmp53_ = gdk_screen_get_default ();
#line 153 "../src/Application.vala"
	_tmp54_ = provider;
#line 153 "../src/Application.vala"
	gtk_style_context_add_provider_for_screen (_tmp53_, (GtkStyleProvider*) _tmp54_, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
#line 157 "../src/Application.vala"
	_tmp55_ = util_get_default ();
#line 157 "../src/Application.vala"
	_tmp56_ = _tmp55_;
#line 157 "../src/Application.vala"
	util_update_theme (_tmp56_);
#line 157 "../src/Application.vala"
	_g_object_unref0 (_tmp56_);
#line 74 "../src/Application.vala"
	_g_object_unref0 (provider);
#line 705 "Application.c"
}

void
planner_create_dir_with_parents (Planner* self,
                                 const gchar* dir)
{
	gchar* path = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	GFile* tmp = NULL;
	const gchar* _tmp2_;
	GFile* _tmp3_;
	GFile* _tmp4_;
#line 160 "../src/Application.vala"
	g_return_if_fail (self != NULL);
#line 160 "../src/Application.vala"
	g_return_if_fail (dir != NULL);
#line 161 "../src/Application.vala"
	_tmp0_ = g_get_user_data_dir ();
#line 161 "../src/Application.vala"
	_tmp1_ = g_strconcat (_tmp0_, dir, NULL);
#line 161 "../src/Application.vala"
	path = _tmp1_;
#line 162 "../src/Application.vala"
	_tmp2_ = path;
#line 162 "../src/Application.vala"
	_tmp3_ = g_file_new_for_path (_tmp2_);
#line 162 "../src/Application.vala"
	tmp = _tmp3_;
#line 163 "../src/Application.vala"
	_tmp4_ = tmp;
#line 163 "../src/Application.vala"
	if (g_file_query_file_type (_tmp4_, 0, NULL) != G_FILE_TYPE_DIRECTORY) {
#line 739 "Application.c"
		const gchar* _tmp5_;
#line 164 "../src/Application.vala"
		_tmp5_ = path;
#line 164 "../src/Application.vala"
		g_mkdir_with_parents (_tmp5_, 0775);
#line 745 "Application.c"
	}
#line 160 "../src/Application.vala"
	_g_object_unref0 (tmp);
#line 160 "../src/Application.vala"
	_g_free0 (path);
#line 751 "Application.c"
}

static gpointer
_g_object_ref0 (gpointer self)
{
#line 169 "../src/Application.vala"
	return self ? g_object_ref (self) : NULL;
#line 759 "Application.c"
}

static gint
planner_main (gchar** args,
              gint args_length1)
{
	Planner* app = NULL;
	Planner* _tmp0_;
	Planner* _tmp1_;
	Planner* _tmp2_;
	gint result = 0;
#line 169 "../src/Application.vala"
	_tmp0_ = planner_get_instance ();
#line 169 "../src/Application.vala"
	_tmp1_ = _tmp0_;
#line 169 "../src/Application.vala"
	_tmp2_ = _g_object_ref0 (_tmp1_);
#line 169 "../src/Application.vala"
	app = _tmp2_;
#line 170 "../src/Application.vala"
	result = g_application_run ((GApplication*) app, (gint) args_length1, args);
#line 170 "../src/Application.vala"
	_g_object_unref0 (app);
#line 170 "../src/Application.vala"
	return result;
#line 785 "Application.c"
}

int
main (int argc,
      char ** argv)
{
#line 168 "../src/Application.vala"
	return planner_main (argv, argc);
#line 794 "Application.c"
}

Planner*
planner_construct (GType object_type)
{
	Planner * self = NULL;
#line 21 "../src/Application.vala"
	self = (Planner*) g_object_new (object_type, NULL);
#line 21 "../src/Application.vala"
	return self;
#line 805 "Application.c"
}

Planner*
planner_new (void)
{
#line 21 "../src/Application.vala"
	return planner_construct (TYPE_PLANNER);
#line 813 "Application.c"
}

Planner*
planner_get_instance (void)
{
	Planner* result;
	Planner* _tmp0_;
	Planner* _tmp2_;
#line 32 "../src/Application.vala"
	_tmp0_ = planner__instance;
#line 32 "../src/Application.vala"
	if (_tmp0_ == NULL) {
#line 826 "Application.c"
		Planner* _tmp1_;
#line 33 "../src/Application.vala"
		_tmp1_ = planner_new ();
#line 33 "../src/Application.vala"
		_g_object_unref0 (planner__instance);
#line 33 "../src/Application.vala"
		planner__instance = _tmp1_;
#line 834 "Application.c"
	}
#line 35 "../src/Application.vala"
	_tmp2_ = planner__instance;
#line 35 "../src/Application.vala"
	result = _tmp2_;
#line 35 "../src/Application.vala"
	return result;
#line 842 "Application.c"
}

static GObject *
planner_constructor (GType type,
                     guint n_construct_properties,
                     GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	Planner * self;
	GApplicationFlags _tmp0_;
	GApplicationFlags _tmp1_;
	gchar* langpack_dir = NULL;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	GSettings* _tmp4_;
	ServicesEventBus* _tmp5_;
#line 56 "../src/Application.vala"
	parent_class = G_OBJECT_CLASS (planner_parent_class);
#line 56 "../src/Application.vala"
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
#line 56 "../src/Application.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PLANNER, Planner);
#line 57 "../src/Application.vala"
	g_application_set_application_id ((GApplication*) self, "com.github.alainm23.planner");
#line 58 "../src/Application.vala"
	_tmp0_ = g_application_get_flags ((GApplication*) self);
#line 58 "../src/Application.vala"
	_tmp1_ = _tmp0_;
#line 58 "../src/Application.vala"
	g_application_set_flags ((GApplication*) self, _tmp1_ | G_APPLICATION_HANDLES_OPEN);
#line 60 "../src/Application.vala"
	setlocale (LC_ALL, "");
#line 61 "../src/Application.vala"
	_tmp2_ = g_build_filename (CONSTANTS_INSTALL_PREFIX, "share", "locale", NULL);
#line 61 "../src/Application.vala"
	langpack_dir = _tmp2_;
#line 62 "../src/Application.vala"
	_tmp3_ = langpack_dir;
#line 62 "../src/Application.vala"
	bindtextdomain (CONSTANTS_GETTEXT_PACKAGE, _tmp3_);
#line 63 "../src/Application.vala"
	bind_textdomain_codeset (CONSTANTS_GETTEXT_PACKAGE, "UTF-8");
#line 64 "../src/Application.vala"
	textdomain (CONSTANTS_GETTEXT_PACKAGE);
#line 66 "../src/Application.vala"
	planner_create_dir_with_parents (self, "/com.github.alainm23.planner");
#line 68 "../src/Application.vala"
	_tmp4_ = g_settings_new ("com.github.alainm23.planner");
#line 68 "../src/Application.vala"
	_g_object_unref0 (planner_settings);
#line 68 "../src/Application.vala"
	planner_settings = _tmp4_;
#line 69 "../src/Application.vala"
	_tmp5_ = services_event_bus_new ();
#line 69 "../src/Application.vala"
	_g_object_unref0 (planner_event_bus);
#line 69 "../src/Application.vala"
	planner_event_bus = _tmp5_;
#line 71 "../src/Application.vala"
	g_application_add_main_option_entries ((GApplication*) self, PLANNER_PLANNER_OPTIONS);
#line 56 "../src/Application.vala"
	_g_free0 (langpack_dir);
#line 56 "../src/Application.vala"
	return obj;
#line 908 "Application.c"
}

static void
planner_class_init (PlannerClass * klass,
                    gpointer klass_data)
{
	gchar* _tmp0_;
#line 21 "../src/Application.vala"
	planner_parent_class = g_type_class_peek_parent (klass);
#line 21 "../src/Application.vala"
	((GApplicationClass *) klass)->activate = (void (*) (GApplication*)) planner_real_activate;
#line 21 "../src/Application.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_planner_get_property;
#line 21 "../src/Application.vala"
	G_OBJECT_CLASS (klass)->constructor = planner_constructor;
#line 21 "../src/Application.vala"
	G_OBJECT_CLASS (klass)->finalize = planner_finalize;
#line 42 "../src/Application.vala"
	_tmp0_ = g_strdup ("");
#line 42 "../src/Application.vala"
	planner_lang = _tmp0_;
#line 930 "Application.c"
}

static void
planner_instance_init (Planner * self,
                       gpointer klass)
{
#line 22 "../src/Application.vala"
	self->main_window = NULL;
#line 939 "Application.c"
}

static void
planner_finalize (GObject * obj)
{
	Planner * self;
#line 21 "../src/Application.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PLANNER, Planner);
#line 22 "../src/Application.vala"
	_g_object_unref0 (self->main_window);
#line 21 "../src/Application.vala"
	G_OBJECT_CLASS (planner_parent_class)->finalize (obj);
#line 952 "Application.c"
}

static GType
planner_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlannerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) planner_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Planner), 0, (GInstanceInitFunc) planner_instance_init, NULL };
	GType planner_type_id;
	planner_type_id = g_type_register_static (gtk_application_get_type (), "Planner", &g_define_type_info, 0);
	return planner_type_id;
}

GType
planner_get_type (void)
{
	static volatile gsize planner_type_id__volatile = 0;
	if (g_once_init_enter (&planner_type_id__volatile)) {
		GType planner_type_id;
		planner_type_id = planner_get_type_once ();
		g_once_init_leave (&planner_type_id__volatile, planner_type_id);
	}
	return planner_type_id__volatile;
}

static void
_vala_planner_get_property (GObject * object,
                            guint property_id,
                            GValue * value,
                            GParamSpec * pspec)
{
	Planner * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_PLANNER, Planner);
#line 21 "../src/Application.vala"
	switch (property_id) {
#line 986 "Application.c"
		default:
#line 21 "../src/Application.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 21 "../src/Application.vala"
		break;
#line 992 "Application.c"
	}
}

static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gint i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gint
_vala_array_length (gpointer array)
{
	gint length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

